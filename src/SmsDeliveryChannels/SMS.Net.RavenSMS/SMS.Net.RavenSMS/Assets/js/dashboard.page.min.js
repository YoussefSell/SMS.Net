/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

'use strict';

/* Chart.js docs: https://www.chartjs.org/ */
window.chartColors = {
	green: '#75c181',
	gray: '#a9b5c9',
	text: '#252930',
	border: '#e7e9ed'
};

/* Random number generator for demo purpose */
var randomDataPoint = function () { return Math.round(Math.random() * 10000) };

//Chart.js Line Chart Example 
var lineChartConfig = {
	type: 'line',

	data: {
		labels: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'],

		datasets: [{
			label: 'Current week',
			fill: false,
			backgroundColor: window.chartColors.green,
			borderColor: window.chartColors.green,
			data: [
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint()
			],
		}, {
			label: 'Previous week',
			borderDash: [3, 5],
			backgroundColor: window.chartColors.gray,
			borderColor: window.chartColors.gray,

			data: [
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint(),
				randomDataPoint()
			],
			fill: false,
		}]
	},
	options: {
		responsive: true,
		aspectRatio: 1.5,

		legend: {
			display: true,
			position: 'bottom',
			align: 'end',
		},

		title: {
			display: true,
			text: 'Chart.js Line Chart Example',

		},
		tooltips: {
			mode: 'index',
			intersect: false,
			titleMarginBottom: 10,
			bodySpacing: 10,
			xPadding: 16,
			yPadding: 16,
			borderColor: window.chartColors.border,
			borderWidth: 1,
			backgroundColor: '#fff',
			bodyFontColor: window.chartColors.text,
			titleFontColor: window.chartColors.text,

			callbacks: {
				//Ref: https://stackoverflow.com/questions/38800226/chart-js-add-commas-to-tooltip-and-y-axis
				label: function (tooltipItem, data) {
					if (parseInt(tooltipItem.value) >= 1000) {
						return "$" + tooltipItem.value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
					} else {
						return '$' + tooltipItem.value;
					}
				}
			},

		},
		hover: {
			mode: 'nearest',
			intersect: true
		},
		scales: {
			xAxes: [{
				display: true,
				gridLines: {
					drawBorder: false,
					color: window.chartColors.border,
				},
				scaleLabel: {
					display: false,

				}
			}],
			yAxes: [{
				display: true,
				gridLines: {
					drawBorder: false,
					color: window.chartColors.border,
				},
				scaleLabel: {
					display: false,
				},
				ticks: {
					beginAtZero: true,
					userCallback: function (value, index, values) {
						return '$' + value.toLocaleString();   //Ref: https://stackoverflow.com/questions/38800226/chart-js-add-commas-to-tooltip-and-y-axis
					}
				},
			}]
		}
	}
};

// Chart.js Bar Chart Example 
var barChartConfig = {
	type: 'bar',

	data: {
		labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
		datasets: [{
			label: 'Orders',
			backgroundColor: window.chartColors.green,
			borderColor: window.chartColors.green,
			borderWidth: 1,
			maxBarThickness: 16,

			data: [
				23,
				45,
				76,
				75,
				62,
				37,
				83
			]
		}]
	},
	options: {
		responsive: true,
		aspectRatio: 1.5,
		legend: {
			position: 'bottom',
			align: 'end',
		},
		title: {
			display: true,
			text: 'Chart.js Bar Chart Example'
		},
		tooltips: {
			mode: 'index',
			intersect: false,
			titleMarginBottom: 10,
			bodySpacing: 10,
			xPadding: 16,
			yPadding: 16,
			borderColor: window.chartColors.border,
			borderWidth: 1,
			backgroundColor: '#fff',
			bodyFontColor: window.chartColors.text,
			titleFontColor: window.chartColors.text,

		},
		scales: {
			xAxes: [{
				display: true,
				gridLines: {
					drawBorder: false,
					color: window.chartColors.border,
				},

			}],
			yAxes: [{
				display: true,
				gridLines: {
					drawBorder: false,
					color: window.chartColors.borders,
				},


			}]
		}

	}
}

// Generate charts on load
window.addEventListener('load', function () {

	var lineChart = document.getElementById('canvas-linechart').getContext('2d');
	window.myLine = new Chart(lineChart, lineChartConfig);

	var barChart = document.getElementById('canvas-barchart').getContext('2d');
	window.myBar = new Chart(barChart, barChartConfig);
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNoYXJ0LmpzIiwiZGFzaGJvYXJkLnBhZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeDJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZGFzaGJvYXJkLnBhZ2UubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgbW9kdWxlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG5NYXRoLmxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbn07XG5cbk1hdGgubG9nMTAgPSBNYXRoLmxvZzEwIHx8IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVscGVycyA9IHtcbiAgICBhdmc6IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIHYgPSAwO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyci5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdiArPSBhcnJbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYgLyBhcnIubGVuZ3RoO1xuICAgIH0sXG4gICAgbWluOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciB2ID0gYXJyWzBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyci5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIHYyID0gYXJyW2luZGV4XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodjIpKSB2MiA9IEhlbHBlcnMuYXZnKHYyKTtcbiAgICAgICAgaWYgKHYyIDwgdikgdiA9IHYyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHYpO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciB2ID0gMDtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcnIubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciB2MiA9IGFycltpbmRleF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYyKSkgdjIgPSBIZWxwZXJzLmF2Zyh2Mik7XG4gICAgICAgIGlmICh2MiA+IHYpIHYgPSB2MjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCB2KTtcbiAgICB9LFxuICAgIHVwcGVyTWF4OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciB2ID0gMDtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcnIubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciB2MiA9IGFycltpbmRleF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYyKSkgdjIgPSBIZWxwZXJzLm1heCh2Mik7XG4gICAgICAgIGlmICh2MiA+IHYpIHYgPSB2MjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCB2KTtcbiAgICB9LFxuICAgIGxvd2VyTWluOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciB2ID0gYXJyWzBdIHx8IEluZmluaXR5O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHYgPSBIZWxwZXJzLmxvd2VyTWluKHYpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyci5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIHYyID0gYXJyW2luZGV4XTtcbiAgICAgICAgaWYgKHYyID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2MikpIHYyID0gSGVscGVycy5sb3dlck1pbih2Mik7XG4gICAgICAgIGlmICh2MiA8IHYpIHYgPSB2MjtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTih2KSB8fCAhaXNGaW5pdGUodikpIHYgPSAwO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHYpO1xuICAgIH0sXG4gICAgbmljZU51bWJlcnM6IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJhbmdlKSk7XG4gICAgICB2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgICB2YXIgbmljZUZyYWN0aW9uO1xuICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgIGlmIChmcmFjdGlvbiA8IDEuNSkgbmljZUZyYWN0aW9uID0gMTtcbiAgICAgICAgZWxzZSBpZiAoZnJhY3Rpb24gPCAzKSBuaWNlRnJhY3Rpb24gPSAyO1xuICAgICAgICBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIG5pY2VGcmFjdGlvbiA9IDU7XG4gICAgICAgIGVsc2UgbmljZUZyYWN0aW9uID0gMTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZnJhY3Rpb24gPD0gMS4wKSBuaWNlRnJhY3Rpb24gPSAxO1xuICAgICAgICBlbHNlIGlmIChmcmFjdGlvbiA8PSAyKSBuaWNlRnJhY3Rpb24gPSAyO1xuICAgICAgICBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSBuaWNlRnJhY3Rpb24gPSA1O1xuICAgICAgICBlbHNlIG5pY2VGcmFjdGlvbiA9IDEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgfSxcbiAgICBnZXRMaW5lYXJUaWNrczogZnVuY3Rpb24obWluLCBtYXgsIG1heFRpY2tzKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBIZWxwZXJzLm5pY2VOdW1iZXJzKG1heCAtIG1pbiwgZmFsc2UpO1xuICAgICAgdmFyIHRpY2tTcGFjaW5nID0gSGVscGVycy5uaWNlTnVtYmVycyhyYW5nZSAvIChtYXhUaWNrcyAtIDEpLCB0cnVlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguZmxvb3IobWluIC8gdGlja1NwYWNpbmcpICogdGlja1NwYWNpbmcsXG4gICAgICAgIE1hdGguY2VpbChtYXggLyB0aWNrU3BhY2luZykgKiB0aWNrU3BhY2luZyxcbiAgICAgICAgdGlja1NwYWNpbmdcbiAgICAgIF07XG4gICAgfSxcbiAgICBnZXRGb250OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLnN0eWxlID0gb3B0aW9ucy5zdHlsZSB8fCAnbm9ybWFsJztcbiAgICAgIG9wdGlvbnMudmFyaWFudCA9IG9wdGlvbnMudmFyaWFudCB8fCAnbm9ybWFsJztcbiAgICAgIG9wdGlvbnMud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgfHwgJ2xpZ2h0ZXInO1xuICAgICAgb3B0aW9ucy5zaXplID0gb3B0aW9ucy5zaXplIHx8ICcxMic7XG4gICAgICBvcHRpb25zLmZhbWlseSA9IG9wdGlvbnMuZmFtaWx5IHx8ICdBcmlhbCc7XG4gICAgICByZXR1cm4gW29wdGlvbnMuc3R5bGUsIG9wdGlvbnMudmFyaWFudCwgb3B0aW9ucy53ZWlnaHQsIG9wdGlvbnMuc2l6ZSArICdweCcsIG9wdGlvbnMuZmFtaWx5XS5qb2luKCcgJyk7XG4gICAgfSxcbiAgICBnZXRBeGlzUmF0aW86IGZ1bmN0aW9uKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJhckNoYXJ0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEJhckNoYXJ0KGN0eCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5tb3VzZUxpc3RlbmVycyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50SGludCA9IG51bGw7XG4gICAgICB0aGlzLmZpbGxSZWdpb25zID0gW11cbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgZm9udDogJ0hlbHZldGljYScsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBmb250U2l6ZVRpdGxlOiAyNCxcbiAgICAgICAgZm9udFNpemVBeGVzOiAyMCxcbiAgICAgICAgZm9udFNpemVUaWNrczogMTgsXG4gICAgICAgIGZvbnRTaXplTGFiZWxzOiAxOCxcbiAgICAgICAgZm9udERhdGFUYWdzOiAxOCxcbiAgICAgICAgZm9udFNpemVMZWdlbmQ6IDE4LFxuICAgICAgICBmb250U2l6ZUhpbnQ6IDE4LFxuICAgICAgICBwYWRkaW5nUGVyY2VudEJhcnM6IDAuMTAsXG4gICAgICAgIHBhZGRpbmdQZXJjZW50VGlja3M6IDAuMTUsXG4gICAgICAgIHBhZGRpbmdQaXhlbHNWZXJ0aWNhbDogMTAsXG4gICAgICAgIHBhZGRpbmdQaXhlbHNIb3Jpem9udGFsOiAxMCxcbiAgICAgICAgcGFkZGluZ1BpeGVsc1RpY2tzOiAxMCxcbiAgICAgICAgbWF4V2lkdGhCYXJzOiAwLFxuICAgICAgICBmaWxsQ29sb3JCYWNrZ3JvdW5kOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcbiAgICAgICAgc3Ryb2tlQ29sb3JCYXJzOiAncmdiKDAsIDAsIDApJyxcbiAgICAgICAgZmlsbENvbG9yQmFyczogJ3JnYmEoMTgwLCAxODAsIDE4MCwgMC4yNSknLFxuICAgICAgICBzY2FsZVN0eWxlOiAnbGluZWFyJyxcbiAgICAgICAgYmFyU3R5bGU6ICdub25lJyxcbiAgICAgICAgc3RhY2tlZEJhclBhZGRpbmc6IDMsXG4gICAgICAgIGRlZmF1bHRNYXhUaWNrOiAwLFxuICAgICAgICBwaXhlbHNMZWdlbmRTcXVhcmU6IDEwLFxuICAgICAgICByYWRpdXNEb3Q6IDUsXG4gICAgICAgIGZpbGxDb2xvckxlZ2VuZDogJ3JnYigyMzAsIDIzMCwgMjMwKScsXG4gICAgICAgIHRpY2tGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIHRpY2tGb3JtYXR0ZXJNZWFzdXJlOiBudWxsLFxuICAgICAgICBmaWxsUmVnaW9uOiAnbm9ybWFsJ1xuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMuY29udGVudCA9IHsgfTtcbiAgICAgIHRoaXMubGFiZWxQb3NpdGlvbnMgPSB7IH1cbiAgICB9XG5cbiAgICBCYXJDaGFydC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb25zIG11c3QgYmUgb2JqZWN0cy4nKTtcbiAgICAgIH0gZWxzZSBpZiAoIShjb250ZW50Lmhhc093blByb3BlcnR5KCdsYWJlbHMnKSAmJiBjb250ZW50Lmhhc093blByb3BlcnR5KCdkYXRhJykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiBtdXN0IHNwZWNpZnkgbGFiZWxzIGFuZCBkYXRhLicpO1xuICAgICAgfSBlbHNlIGlmICghKEFycmF5LmlzQXJyYXkoY29udGVudC5sYWJlbHMpICYmIEFycmF5LmlzQXJyYXkoY29udGVudC5kYXRhKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYWJlbHMgYW5kIGRhdGEgbXVzdCBiZSBhcnJheXMuJyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQubGFiZWxzLmxlbmd0aCAhPT0gY29udGVudC5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhYmVscyBhbmQgZGF0YSBsZW5ndGggbXVzdCBtYXRjaC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQuX2RhdGFfc3RhbmRhcmRfZGV2aWF0aW9uID0gW107XG4gICAgICBjb250ZW50Ll9kYXRhX3N0YW5kYXJkX2Vycm9yID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXNBcnIgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQuZGF0YVtpXSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGVTdHlsZSA9PT0gJ2xvZzInKSB7XG4gICAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpMyA9IDA7IGkzIDwgY29udGVudC5kYXRhW2ldLmxlbmd0aDsgKytpMykgY29udGVudC5kYXRhW2ldW2kzXSA9IE1hdGgubG9nMihjb250ZW50LmRhdGFbaV1baTNdKTtcbiAgICAgICAgICB9IGVsc2UgY29udGVudC5kYXRhW2ldID0gTWF0aC5sb2cyKGNvbnRlbnQuZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgdmFyIG1lYW4gPSBIZWxwZXJzLmF2Zyhjb250ZW50LmRhdGFbaV0pO1xuICAgICAgICAgIHZhciBhY2MgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBjb250ZW50LmRhdGFbaV0ubGVuZ3RoOyArK2kyKSBhY2MgKz0gTWF0aC5wb3cobWVhbiAtIGNvbnRlbnQuZGF0YVtpXVtpMl0sIDIpO1xuICAgICAgICAgIGFjYyA9IE1hdGguc3FydChhY2MgLyAoY29udGVudC5kYXRhW2ldLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICBjb250ZW50Ll9kYXRhX3N0YW5kYXJkX2RldmlhdGlvbi5wdXNoKGFjYyk7XG4gICAgICAgICAgY29udGVudC5fZGF0YV9zdGFuZGFyZF9lcnJvci5wdXNoKGFjYyAvIE1hdGguc3FydChjb250ZW50LmRhdGFbaV0ubGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudC5fZGF0YV9zdGFuZGFyZF9kZXZpYXRpb24ucHVzaCgwKTtcbiAgICAgICAgICBjb250ZW50Ll9kYXRhX3N0YW5kYXJkX2Vycm9yLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH07XG5cbiAgICBCYXJDaGFydC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgIH07XG5cbiAgICBCYXJDaGFydC5wcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIHJlcyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5tb3VzZUxpc3RlbmVycy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgaWYgKChyZXMgPSB0aGlzLm1vdXNlTGlzdGVuZXJzW2luZGV4XSh4LCB5KSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXMgfHwgKHR5cGVvZiByZXMpICE9PSAnb2JqZWN0JyB8fCAhcmVzLmhhc093blByb3BlcnR5KCdpbmRleCcpIHx8ICFyZXMuaGFzT3duUHJvcGVydHkoJ2RyYXdJbmRleCcpKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRIaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50SGludCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmN1cnJlbnRIaW50O1xuICAgICAgaWYgKGNoID09IG51bGwgfHwgY2guaW5kZXggIT0gcmVzLmluZGV4IHx8IGNoLmRyYXdJbmRleCAhPSByZXMuZHJhd0luZGV4KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhpbnQgPSByZXM7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEJhckNoYXJ0LnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhYmVsUG9zaXRpb25zID0geyB9XG4gICAgICB0aGlzLm1vdXNlTGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLmZpbGxSZWdpb25zID0gW107XG5cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4LCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgdmFyIHdpZHRoID0gY3R4LmNhbnZhcy53aWR0aCwgaGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtMC41LCAtMC41KTtcbiAgICAgIHZhciByZW1haW5pbmdXaWR0aCA9IHdpZHRoLCByZW1haW5pbmdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgaW5kZXg7XG5cbiAgICAgIGlmIChvcHRpb25zLmZpbGxDb2xvckJhY2tncm91bmQgIT0gbnVsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3JCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3BZUGFkZGluZyA9IG9wdGlvbnMucGFkZGluZ1BpeGVsc0hvcml6b250YWw7XG4gICAgICByZW1haW5pbmdIZWlnaHQgLT0gb3B0aW9ucy5wYWRkaW5nUGl4ZWxzSG9yaXpvbnRhbDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDAsIDApJztcbiAgICAgIC8qIERyYXcgdGl0bGUgb2YgYmFyIGNoYXJ0ICovXG4gICAgICBpZiAoY29udGVudC50aXRsZSAhPSBudWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5mb250ID0gSGVscGVycy5nZXRGb250KHsgd2VpZ2h0OiBvcHRpb25zLmZvbnRXZWlnaHQsIHNpemU6IG9wdGlvbnMuZm9udFNpemVUaXRsZSwgZmFtaWx5OiBvcHRpb25zLmZvbnQgfSk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQudGl0bGUsIHdpZHRoIC8gMiwgdG9wWVBhZGRpbmcgKyBvcHRpb25zLmZvbnRTaXplVGl0bGUpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZW1haW5pbmdIZWlnaHQgLT0gb3B0aW9ucy5mb250U2l6ZVRpdGxlICogMS4yNTtcbiAgICAgICAgdG9wWVBhZGRpbmcgKz0gb3B0aW9ucy5mb250U2l6ZVRpdGxlICogMS4yNTtcbiAgICAgIH1cblxuICAgICAgLyogQ29tcHV0ZSByZXF1aXJlZCBsZWZ0IHBhZGRpbmcgKi9cbiAgICAgIHZhciBsZWZ0WFBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmdQaXhlbHNWZXJ0aWNhbDtcbiAgICAgIHJlbWFpbmluZ1dpZHRoICAtPSBvcHRpb25zLnBhZGRpbmdQaXhlbHNWZXJ0aWNhbDtcblxuICAgICAgdmFyIGxlZnRYRHJhd1lMYWJlbCA9IG51bGw7XG4gICAgICBpZiAoY29udGVudC55QXhpcyAhPSBudWxsKSB7XG4gICAgICAgIGxlZnRYRHJhd1lMYWJlbCA9IGxlZnRYUGFkZGluZyArIG9wdGlvbnMuZm9udFNpemVBeGVzICogMC41O1xuICAgICAgICByZW1haW5pbmdXaWR0aCAtPSBvcHRpb25zLmZvbnRTaXplQXhlcyAqIDEuMjU7XG4gICAgICAgIGxlZnRYUGFkZGluZyArPSBvcHRpb25zLmZvbnRTaXplQXhlcyAqIDEuMjU7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZm9udCA9IEhlbHBlcnMuZ2V0Rm9udCh7IHdlaWdodDogb3B0aW9ucy5mb250V2VpZ2h0LCBzaXplOiBvcHRpb25zLmZvbnRTaXplVGlja3MsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgdmFyIG1heENoYXJ0VmFsdWUsIG1pbkNoYXJ0VmFsdWU7XG4gICAgICBpZiAob3B0aW9ucy5iYXJTdHlsZSA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICAgIG1heENoYXJ0VmFsdWUgPSAwO1xuICAgICAgICBtaW5DaGFydFZhbHVlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGNtSW5kZXggPSAwOyBjbUluZGV4IDwgY29udGVudC5kYXRhLmxlbmd0aDsgKytjbUluZGV4KSB7XG4gICAgICAgICAgdmFyIGRvQjtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb0IgPSBjb250ZW50LmRhdGFbY21JbmRleF0pKSB7XG4gICAgICAgICAgICB2YXIgdGVtcFN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpaTIgPSAwOyBpaTIgPCBkb0IubGVuZ3RoOyArK2lpMikgdGVtcFN1bSArPSBkb0JbaWkyXTtcbiAgICAgICAgICAgIG1heENoYXJ0VmFsdWUgPSBNYXRoLm1heChtYXhDaGFydFZhbHVlLCB0ZW1wU3VtKTtcbiAgICAgICAgICAgIG1pbkNoYXJ0VmFsdWUgPSBNYXRoLm1pbihtaW5DaGFydFZhbHVlLCB0ZW1wU3VtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4Q2hhcnRWYWx1ZSA9IE1hdGgubWF4KG1heENoYXJ0VmFsdWUsIGNvbnRlbnQuZGF0YVtjbUluZGV4XSk7XG4gICAgICAgICAgICBtaW5DaGFydFZhbHVlID0gTWF0aC5taW4obWluQ2hhcnRWYWx1ZSwgY29udGVudC5kYXRhW2NtSW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heENoYXJ0VmFsdWUgPSBIZWxwZXJzLnVwcGVyTWF4KGNvbnRlbnQuZGF0YSk7XG4gICAgICAgIG1pbkNoYXJ0VmFsdWUgPSBIZWxwZXJzLmxvd2VyTWluKGNvbnRlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZVN0eWxlLmluZGV4T2YoJ2FkYXB0aXZlJykgPT09IDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGVTdHlsZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIGZsb2F0ZXIgPSBwYXJzZUZsb2F0KG9wdGlvbnMuc2NhbGVTdHlsZS5zcGxpdCgvWzpdLylbMV0pO1xuICAgICAgICAgIG1pbkNoYXJ0VmFsdWUgKj0gZmxvYXRlcjtcbiAgICAgICAgICBtYXhDaGFydFZhbHVlICo9IDEgKyAoMSAtIGZsb2F0ZXIpIC8gMi4wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgbWluQ2hhcnRWYWx1ZSA9IDA7XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0TWF4VGljayA+IG1heENoYXJ0VmFsdWUpIG1heENoYXJ0VmFsdWUgPSBvcHRpb25zLmRlZmF1bHRNYXhUaWNrO1xuICAgICAgaWYgKGNvbnRlbnQuYmFycyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoY29udGVudC5iYXJzKSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBjb250ZW50LmJhcnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgdmFyIGNidiA9IGNvbnRlbnQuYmFyc1tpbmRleF0udmFsdWU7XG4gICAgICAgICAgaWYgKGlzTmFOKGNidikpIGNvbnRpbnVlO1xuICAgICAgICAgIG1heENoYXJ0VmFsdWUgPSBNYXRoLm1heChtYXhDaGFydFZhbHVlLCBjYnYpO1xuICAgICAgICAgIG1pbkNoYXJ0VmFsdWUgPSBNYXRoLm1pbihtaW5DaGFydFZhbHVlLCBjYnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWF4WUF4aXNUaWNrV2lkdGggPSBvcHRpb25zLnNjYWxlU3R5bGUgPT0gJ2xvZzInID8gTWF0aC5jZWlsKE1hdGgucG93KDIsIG1heENoYXJ0VmFsdWUpKSA6IChNYXRoLmNlaWwobWF4Q2hhcnRWYWx1ZSkgKyAnLjAwJyk7XG4gICAgICBpZiAob3B0aW9ucy50aWNrRm9ybWF0dGVyTWVhc3VyZSAhPSBudWxsKSBtYXhZQXhpc1RpY2tXaWR0aCA9IG9wdGlvbnMudGlja0Zvcm1hdHRlck1lYXN1cmU7XG4gICAgICBtYXhZQXhpc1RpY2tXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChtYXhZQXhpc1RpY2tXaWR0aCkud2lkdGg7XG4gICAgICBtYXhZQXhpc1RpY2tXaWR0aCA9IE1hdGguY2VpbChtYXhZQXhpc1RpY2tXaWR0aCkgKyBvcHRpb25zLnBhZGRpbmdQaXhlbHNUaWNrcztcbiAgICAgIHJlbWFpbmluZ1dpZHRoIC09IG1heFlBeGlzVGlja1dpZHRoO1xuICAgICAgbGVmdFhQYWRkaW5nICs9IG1heFlBeGlzVGlja1dpZHRoO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdmFyIHJpZ2h0WFBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmdQaXhlbHNWZXJ0aWNhbDtcbiAgICAgIHJlbWFpbmluZ1dpZHRoIC09IG9wdGlvbnMucGFkZGluZ1BpeGVsc1ZlcnRpY2FsO1xuXG4gICAgICAvKiBEcmF3IGxlZ2VuZCAqL1xuICAgICAgaWYgKGNvbnRlbnQubGVnZW5kICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShjb250ZW50LmxlZ2VuZCkpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZUxlZ2VuZCwgZmFtaWx5OiBvcHRpb25zLmZvbnQgfSk7XG4gICAgICAgIHZhciBtYXhMV2lkdGggPSAwO1xuICAgICAgICBmb3IgKHZhciBsSW5kZXggPSAwOyBsSW5kZXggPCBjb250ZW50LmxlZ2VuZC5sZW5ndGg7ICsrbEluZGV4KSB7XG4gICAgICAgICAgbWF4TFdpZHRoID0gTWF0aC5tYXgobWF4TFdpZHRoLCBjdHgubWVhc3VyZVRleHQoY29udGVudC5sZWdlbmRbbEluZGV4XS5sYWJlbCkud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIG1heExXaWR0aCA9IE1hdGguY2VpbChtYXhMV2lkdGgpO1xuICAgICAgICBtYXhMV2lkdGggKz0gb3B0aW9ucy5waXhlbHNMZWdlbmRTcXVhcmUgKyA4O1xuICAgICAgICB2YXIgbGVnZW5kRW50cmllc1BlckxpbmUgPSBNYXRoLmZsb29yKChyZW1haW5pbmdXaWR0aCAtIG9wdGlvbnMucGFkZGluZ1BpeGVsc0hvcml6b250YWwgKiAyKSAvIG1heExXaWR0aCk7XG4gICAgICAgIHZhciBsTFJlcUhlaWdodCA9IE1hdGguY2VpbChjb250ZW50LmxlZ2VuZC5sZW5ndGggLyBsZWdlbmRFbnRyaWVzUGVyTGluZSkgKiBvcHRpb25zLmZvbnRTaXplTGVnZW5kICogMS41O1xuICAgICAgICByZW1haW5pbmdIZWlnaHQgLT0gbExSZXFIZWlnaHQ7XG4gICAgICAgIGJvdHRvbVlQYWRkaW5nICs9IGxMUmVxSGVpZ2h0O1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3JMZWdlbmQ7XG4gICAgICAgIHZhciBiU1gsIGJTWTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGJTWCA9IGxlZnRYUGFkZGluZywgYlNZID0gdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGJTWCArIHJlbWFpbmluZ1dpZHRoLCBiU1kpO1xuICAgICAgICBjdHgubGluZVRvKGJTWCArIHJlbWFpbmluZ1dpZHRoLCBiU1kgKyBsTFJlcUhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oYlNYLCBiU1kgKyBsTFJlcUhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oYlNYLCBiU1kpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgZm9yIChsSW5kZXggPSAwOyBsSW5kZXggPCBjb250ZW50LmxlZ2VuZC5sZW5ndGg7ICsrbEluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlZ0xpbmUgPSBNYXRoLmZsb29yKGxJbmRleCAvIGxlZ2VuZEVudHJpZXNQZXJMaW5lKTtcbiAgICAgICAgICB2YXIgbGVnQ29sID0gbEluZGV4ICUgbGVnZW5kRW50cmllc1BlckxpbmU7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbnRlbnQubGVnZW5kW2xJbmRleF0uY29sb3I7XG4gICAgICAgICAgdmFyIGJveFggPSBiU1ggKyBsZWdDb2wgKiBtYXhMV2lkdGggKyAzLCBib3hZID0gYlNZICsgbGVnTGluZSAqIG9wdGlvbnMuZm9udFNpemVMZWdlbmQgKiAxLjUgKyBvcHRpb25zLmZvbnRTaXplTGVnZW5kICogMC41O1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGJveFgsIGJveFkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYm94WCArIG9wdGlvbnMucGl4ZWxzTGVnZW5kU3F1YXJlLCBib3hZKTtcbiAgICAgICAgICBjdHgubGluZVRvKGJveFggKyBvcHRpb25zLnBpeGVsc0xlZ2VuZFNxdWFyZSwgYm94WSArIG9wdGlvbnMucGl4ZWxzTGVnZW5kU3F1YXJlKTtcbiAgICAgICAgICBjdHgubGluZVRvKGJveFgsIGJveFkgKyBvcHRpb25zLnBpeGVsc0xlZ2VuZFNxdWFyZSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhib3hYLCBib3hZKTtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LmxlZ2VuZFtsSW5kZXhdLmxhYmVsLCBib3hYICsgMyArIG9wdGlvbnMucGl4ZWxzTGVnZW5kU3F1YXJlLCBib3hZICsgb3B0aW9ucy5mb250U2l6ZUxlZ2VuZCAqIDAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICAvKiBEcmF3IHgtYXhpcyBsYWJlbCBvZiBiYXIgY2hhcnQgKi9cbiAgICAgIHZhciBib3R0b21ZUGFkZGluZyA9IG9wdGlvbnMucGFkZGluZ1BpeGVsc0hvcml6b250YWw7XG4gICAgICByZW1haW5pbmdIZWlnaHQgLT0gb3B0aW9ucy5wYWRkaW5nUGl4ZWxzSG9yaXpvbnRhbDtcbiAgICAgIGlmIChjb250ZW50LnhBeGlzICE9IG51bGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZUF4ZXMsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQueEF4aXMsICh3aWR0aCAtIHJlbWFpbmluZ1dpZHRoKSArIHJlbWFpbmluZ1dpZHRoIC8gMiwgdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSBib3R0b21ZUGFkZGluZyk7XG4gICAgICAgIHJlbWFpbmluZ0hlaWdodCAtPSBvcHRpb25zLmZvbnRTaXplQXhlcyAqIDEuNTtcbiAgICAgICAgYm90dG9tWVBhZGRpbmcgKz0gb3B0aW9ucy5mb250U2l6ZUF4ZXMgKiAxLjU7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aFBlckJhciA9IHJlbWFpbmluZ1dpZHRoIC8gY29udGVudC5kYXRhLmxlbmd0aDtcblxuICAgICAgLyogRHJhdyB4LWF4aXMgdG9wIGxhYmVscyAqL1xuICAgICAgaWYgKGNvbnRlbnQudG9wTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHguZm9udCA9IEhlbHBlcnMuZ2V0Rm9udCh7IHdlaWdodDogb3B0aW9ucy5mb250V2VpZ2h0LCBzaXplOiBvcHRpb25zLmZvbnRTaXplTGFiZWxzLCBmYW1pbHk6IG9wdGlvbnMuZm9udCB9KTtcbiAgICAgICAgcmVtYWluaW5nSGVpZ2h0IC09IG9wdGlvbnMuZm9udFNpemVMYWJlbHMgKiAxLjU7XG4gICAgICAgIHRvcFlQYWRkaW5nICs9IG9wdGlvbnMuZm9udFNpemVMYWJlbHMgKiAxLjU7XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvbnRlbnQudG9wTGFiZWxzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgIGNvbnRlbnQudG9wTGFiZWxzW2luZGV4XSxcbiAgICAgICAgICAgIGxlZnRYUGFkZGluZyArIGluZGV4ICogd2lkdGhQZXJCYXIgKyB3aWR0aFBlckJhciAvIDIsXG4gICAgICAgICAgICB0b3BZUGFkZGluZyAtIG9wdGlvbnMuZm9udFNpemVMYWJlbHMgLyAyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICAvKiBEcmF3IHgtYXhpcyBsYWJlbHMgKi9cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgcmVxV2lkdGggPSAwO1xuICAgICAgaWYgKGNvbnRlbnQuZGF0YVRhZ3MgIT0gbnVsbCkge1xuICAgICAgICBjdHguZm9udCA9IEhlbHBlcnMuZ2V0Rm9udCh7IHdlaWdodDogb3B0aW9ucy5mb250V2VpZ2h0LCBzaXplOiBvcHRpb25zLmZvbnREYXRhVGFncywgZmFtaWx5OiBvcHRpb25zLmZvbnQgfSk7XG4gICAgICAgIHZhciBkYXRhVGFncyA9IGNvbnRlbnQuZGF0YVRhZ3M7XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRhdGFUYWdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFUYWdzW2luZGV4XSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4MiA9IDA7IGluZGV4MiA8IGRhdGFUYWdzW2luZGV4XS5sZW5ndGg7ICsraW5kZXgyKSB7XG4gICAgICAgICAgICAgIHJlcVdpZHRoID0gTWF0aC5tYXgocmVxV2lkdGgsIE1hdGguY2VpbChjdHgubWVhc3VyZVRleHQoZGF0YVRhZ3NbaW5kZXhdW2luZGV4Ml0pLndpZHRoICsgNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFXaWR0aCA9IE1hdGgubWF4KHJlcVdpZHRoLCBNYXRoLmNlaWwoY3R4Lm1lYXN1cmVUZXh0KGRhdGFUYWdzW2luZGV4XSkud2lkdGggKyA1KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5mb250ID0gSGVscGVycy5nZXRGb250KHsgd2VpZ2h0OiBvcHRpb25zLmZvbnRXZWlnaHQsIHNpemU6IG9wdGlvbnMuZm9udFNpemVMYWJlbHMsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgdmFyIGNvbXB1dGVkQmFyUGFkZGluZyA9IE1hdGguZmxvb3IoKHdpZHRoUGVyQmFyICogb3B0aW9ucy5wYWRkaW5nUGVyY2VudEJhcnMpIC8gMik7XG4gICAgICB2YXIgd3doID0gd2lkdGhQZXJCYXIgLSBjb21wdXRlZEJhclBhZGRpbmcgKiAyO1xuICAgICAgaWYgKHd3aCA8IHJlcVdpZHRoKSB7XG4gICAgICAgIGNvbXB1dGVkQmFyUGFkZGluZyAtPSBNYXRoLmNlaWwoKHJlcVdpZHRoIC0gd3doKSAvIDIpO1xuICAgICAgICBjb21wdXRlZEJhclBhZGRpbmcgPSBNYXRoLm1heCgwLCBjb21wdXRlZEJhclBhZGRpbmcpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFdpZHRoQmFycyA+IDAgJiYgd3doID4gb3B0aW9ucy5tYXhXaWR0aEJhcnMpIHtcbiAgICAgICAgY29tcHV0ZWRCYXJQYWRkaW5nID0gTWF0aC5mbG9vcigod2lkdGhQZXJCYXIgLSBvcHRpb25zLm1heFdpZHRoQmFycykgLyAyKTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXhUZXh0V2lkdGggPSAwLCBtYXhUZXh0U3RhY2tTaXplID0gMTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvbnRlbnQubGFiZWxzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgdExhYmVsID0gY29udGVudC5sYWJlbHNbaW5kZXhdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0TGFiZWwpKSB7XG4gICAgICAgICAgbWF4VGV4dFN0YWNrU2l6ZSA9IE1hdGgubWF4KG1heFRleHRTdGFja1NpemUsIHRMYWJlbC5sZW5ndGgpO1xuICAgICAgICAgIGZvciAoaW5kZXgyID0gMDsgaW5kZXgyIDwgdExhYmVsLmxlbmd0aDsgKytpbmRleDIpIHtcbiAgICAgICAgICAgIG1heFRleHRXaWR0aCA9IE1hdGgubWF4KG1heFRleHRXaWR0aCwgY3R4Lm1lYXN1cmVUZXh0KHRMYWJlbFtpbmRleDJdKS53aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgbWF4VGV4dFdpZHRoID0gTWF0aC5tYXgobWF4VGV4dFdpZHRoLCBjdHgubWVhc3VyZVRleHQodExhYmVsKS53aWR0aCk7XG4gICAgICB9XG4gICAgICB2YXIgeExhYmVsc1JvdGF0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChtYXhUZXh0V2lkdGggPiB3aWR0aFBlckJhciAtIGNvbXB1dGVkQmFyUGFkZGluZykge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJICogMS41KTtcbiAgICAgICAgeExhYmVsc1JvdGF0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RMYWJlbFkgPSAtb3B0aW9ucy5mb250U2l6ZUxhYmVscztcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvbnRlbnQubGFiZWxzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgY0xhYmVsID0gY29udGVudC5sYWJlbHNbaW5kZXhdO1xuICAgICAgICB2YXIgeCA9IGxlZnRYUGFkZGluZyArIGluZGV4ICogd2lkdGhQZXJCYXIgKyB3aWR0aFBlckJhciAvIDIsIHkgPSB0b3BZUGFkZGluZyArIHJlbWFpbmluZ0hlaWdodCAtIG9wdGlvbnMuZm9udFNpemVMYWJlbHMgLyAyO1xuICAgICAgICBpZiAoeExhYmVsc1JvdGF0ZWQpIHtcbiAgICAgICAgICB5ID0gdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSBtYXhUZXh0V2lkdGggKyA1O1xuICAgICAgICAgIHkgPSBbeCwgeCA9IC15XVswXTtcblxuICAgICAgICAgIGlmICh5IDwgbGFzdExhYmVsWSArIG9wdGlvbnMuZm9udFNpemVMYWJlbHMpIGNvbnRpbnVlO1xuICAgICAgICAgIGxhc3RMYWJlbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHZhciB5VXAgPSBvcHRpb25zLmZvbnRTaXplTGFiZWxzICogKG1heFRleHRTdGFja1NpemUgLSAxKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY0xhYmVsKSkge1xuICAgICAgICAgIGlmICh4TGFiZWxzUm90YXRlZCkge1xuICAgICAgICAgICAgeVVwID0gb3B0aW9ucy5mb250U2l6ZUxhYmVscyAqIChjTGFiZWwubGVuZ3RoIC0gMS41KTtcbiAgICAgICAgICAgIHlVcCAvPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGluZGV4MiA9IDA7IGluZGV4MiA8IGNMYWJlbC5sZW5ndGg7ICsraW5kZXgyKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoY0xhYmVsW2luZGV4Ml0sIHgsIHkgLSB5VXApO1xuICAgICAgICAgICAgeVVwIC09IG9wdGlvbnMuZm9udFNpemVMYWJlbHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4TGFiZWxzUm90YXRlZCkgeVVwID0gLW9wdGlvbnMuZm9udFNpemVMYWJlbHMgKiAwLjI1O1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjTGFiZWwsIHgsIHkgLSB5VXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoeExhYmVsc1JvdGF0ZWQpIHtcbiAgICAgICAgcmVtYWluaW5nSGVpZ2h0IC09IG1heFRleHRXaWR0aCArIDU7XG4gICAgICAgIGJvdHRvbVlQYWRkaW5nICs9IG1heFRleHRXaWR0aCArIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVtVmFsID0gb3B0aW9ucy5mb250U2l6ZUxhYmVscyAqIG1heFRleHRTdGFja1NpemU7XG4gICAgICAgIHJlbVZhbCArPSBvcHRpb25zLmZvbnRTaXplTGFiZWxzICogMC41O1xuICAgICAgICByZW1haW5pbmdIZWlnaHQgLT0gcmVtVmFsO1xuICAgICAgICBib3R0b21ZUGFkZGluZyArPSByZW1WYWw7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAvKiBEcmF3IGJvdW5kYXJpZXMgKi9cbiAgICAgIHZhciBib3VuZFgxID0gbGVmdFhQYWRkaW5nLCBib3VuZFgyID0gbGVmdFhQYWRkaW5nICsgcmVtYWluaW5nV2lkdGg7XG4gICAgICB2YXIgYm91bmRZMSA9IHRvcFlQYWRkaW5nLCBib3VuZFkyID0gdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQ7XG5cbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvbnRlbnQubGFiZWxzLmxlbmd0aDsgKytpbmRleCkgbGFiZWxQb3NpdGlvbnNbaW5kZXhdID0ge1xuICAgICAgICB4U3RhcnQ6IGxlZnRYUGFkZGluZyArIGluZGV4ICogd2lkdGhQZXJCYXIsXG4gICAgICAgIHhFbmQ6IGxlZnRYUGFkZGluZyArICgxICsgaW5kZXgpICogd2lkdGhQZXJCYXIsXG4gICAgICAgIHlTdGFydDogYm91bmRZMSwgeUVuZDogYm91bmRZMlxuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBpZiAoY29udGVudC50b3BMYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBjdHgubW92ZVRvKGJvdW5kWDIsIGJvdW5kWTEpO1xuICAgICAgICBjdHgubGluZVRvKGJvdW5kWDEsIGJvdW5kWTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhib3VuZFgxLCBib3VuZFkxKTtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lVG8oYm91bmRYMSwgYm91bmRZMik7XG4gICAgICBjdHgubGluZVRvKGJvdW5kWDIsIGJvdW5kWTIpO1xuICAgICAgaWYgKGNvbnRlbnQudG9wTGFiZWxzICE9IG51bGwpIGN0eC5saW5lVG8obGVmdFhQYWRkaW5nICsgcmVtYWluaW5nV2lkdGgsIHRvcFlQYWRkaW5nKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIC8qIERyYXcgdG9wIGxhYmVsICovXG4gICAgICBpZiAoY29udGVudC50b3BMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBjdHguZm9udCA9IEhlbHBlcnMuZ2V0Rm9udCh7IHdlaWdodDogb3B0aW9ucy5mb250V2VpZ2h0LCBzaXplOiBvcHRpb25zLmZvbnRTaXplTGFiZWxzLCBmYW1pbHk6IG9wdGlvbnMuZm9udCB9KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQudG9wTGFiZWwsIGxlZnRYUGFkZGluZyAtIDMsIHRvcFlQYWRkaW5nIC0gb3B0aW9ucy5mb250U2l6ZUxhYmVscyAvIDIpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICAvKiBEcmF3IHktYXhpcyBsYWJlbCBvZiBiYXIgY2hhcnQgKi9cbiAgICAgIGlmIChjb250ZW50LnlBeGlzICE9IG51bGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJICogMS41KTtcbiAgICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZUF4ZXMsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQueUF4aXMsIC0odG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLyAyKSwgbGVmdFhEcmF3WUxhYmVsKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLyogRHJhdyB5LWF4aXMgbGFiZWxzICovXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4yMCknO1xuICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZVRpY2tzLCBmYW1pbHk6IG9wdGlvbnMuZm9udCB9KTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdmFyIHRpY2tNZXRhID0gSGVscGVycy5nZXRMaW5lYXJUaWNrcygwLCBtYXhDaGFydFZhbHVlLCBNYXRoLm1heCgyLCByZW1haW5pbmdIZWlnaHQgLyAob3B0aW9ucy5mb250U2l6ZVRpY2tzICogKDEgKyBvcHRpb25zLnBhZGRpbmdQZXJjZW50VGlja3MpKSkpO1xuICAgICAgdmFyIGFscGhhID0gbWF4Q2hhcnRWYWx1ZSAvIG9wdGlvbnMuZm9udFNpemVUaWNrcztcbiAgICAgIG1heENoYXJ0VmFsdWUgPSB0aWNrTWV0YVsxXTtcbiAgICAgIGlmIChtYXhDaGFydFZhbHVlID4gMSkgbWF4Q2hhcnRWYWx1ZSArPSBNYXRoLmNlaWwoYWxwaGEpO1xuICAgICAgZWxzZSBtYXhDaGFydFZhbHVlICs9IGFscGhhO1xuICAgICAgdmFyIHRpY2tzID0gW107XG4gICAgICB3aGlsZSAodGlja01ldGFbMF0gPD0gdGlja01ldGFbMV0pIHtcbiAgICAgICAgdGlja3MucHVzaCh0aWNrTWV0YVswXSk7XG4gICAgICAgIHRpY2tNZXRhWzBdICs9IHRpY2tNZXRhWzJdO1xuICAgICAgfVxuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGlja3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciB0aWNrSGVpZ2h0ID0gTWF0aC5yb3VuZChyZW1haW5pbmdIZWlnaHQgKiBIZWxwZXJzLmdldEF4aXNSYXRpbyhtaW5DaGFydFZhbHVlLCBtYXhDaGFydFZhbHVlLCB0aWNrc1tpbmRleF0pKTtcbiAgICAgICAgaWYgKHRpY2tIZWlnaHQgPCAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGVTdHlsZSA9PSAnbG9nMicgJiYgdGlja3NbaW5kZXhdICE9PSAwKSB0aWNrc1tpbmRleF0gPSBNYXRoLnJvdW5kKE1hdGgucG93KDIsIHRpY2tzW2luZGV4XSkpO1xuICAgICAgICBlbHNlIHRpY2tzW2luZGV4XSA9IE1hdGguZmxvb3IodGlja3NbaW5kZXhdICogMTAwKSAvIDEwMDtcbiAgICAgICAgaWYgKG9wdGlvbnMudGlja0Zvcm1hdHRlciAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zLnRpY2tGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQob3B0aW9ucy50aWNrRm9ybWF0dGVyKHRpY2tzW2luZGV4XSkudG9TdHJpbmcoKSwgbGVmdFhQYWRkaW5nIC0gb3B0aW9ucy5wYWRkaW5nUGl4ZWxzVGlja3MsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gdGlja0hlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2tzW2luZGV4XS50b1N0cmluZygpLCBsZWZ0WFBhZGRpbmcgLSBvcHRpb25zLnBhZGRpbmdQaXhlbHNUaWNrcywgdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSB0aWNrSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT0gMCkgY29udGludWU7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0WFBhZGRpbmcsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gdGlja0hlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdFhQYWRkaW5nICsgcmVtYWluaW5nV2lkdGgsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gdGlja0hlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmIChjb250ZW50LmJhcnMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGNvbnRlbnQuYmFycykpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgY29udGVudC5iYXJzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIHZhciBjQmFyID0gY29udGVudC5iYXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoY0Jhci52YWx1ZSA+IG1heENoYXJ0VmFsdWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZW5kZXJCYXJZID0gdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSBNYXRoLnJvdW5kKHJlbWFpbmluZ0hlaWdodCAqIEhlbHBlcnMuZ2V0QXhpc1JhdGlvKG1pbkNoYXJ0VmFsdWUsIG1heENoYXJ0VmFsdWUsIGNCYXIudmFsdWUpKTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjQmFyLnN0eWxlO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjQmFyLnN0eWxlO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGJvdW5kWDEsIHJlbmRlckJhclkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYm91bmRYMiwgcmVuZGVyQmFyWSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLyogRHJhdyBiYXJzICovXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGxhc3REYXRhID0gbnVsbDtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvbnRlbnQuZGF0YS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIGZpbGxDb2xvckZvckluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yRm9ySW5kZXggPSBudWxsO1xuICAgICAgICBpZiAoY29udGVudC5maWxsQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQuZmlsbENvbG9yKSkgZmlsbENvbG9yRm9ySW5kZXggPSBjdHguZmlsbFN0eWxlID0gY29udGVudC5maWxsQ29sb3JbaW5kZXhdO1xuICAgICAgICAgIGVsc2UgY3R4LmZpbGxTdHlsZSA9IGNvbnRlbnQuZmlsbENvbG9yO1xuICAgICAgICB9IGVsc2UgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yQmFycztcbiAgICAgICAgaWYgKGNvbnRlbnQuc3Ryb2tlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQuc3Ryb2tlQ29sb3IpKSBzdHJva2VDb2xvckZvckluZGV4ID0gY3R4LnN0cm9rZVN0eWxlID0gY29udGVudC5zdHJva2VDb2xvcltpbmRleF07XG4gICAgICAgICAgZWxzZSBjdHguc3Ryb2tlU3R5bGUgPSBjb250ZW50LnN0cm9rZUNvbG9yO1xuICAgICAgICB9IGVsc2UgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5zdHJva2VDb2xvckJhcnM7XG4gICAgICAgIHZhciB2ID0gY29udGVudC5kYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIHZJc0FyciA9IEFycmF5LmlzQXJyYXkodik7XG4gICAgICAgIHZhciByZW5kZXJTdGFydFggPSBsZWZ0WFBhZGRpbmcgKyB3aWR0aFBlckJhciAqIGluZGV4O1xuICAgICAgICBpZiAodklzQXJyICYmIG9wdGlvbnMuYmFyU3R5bGUgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgIHZhciBydW5uaW5nVmFsdWUgPSAwLCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBkcmF3SW5kZXggPSAwOyBkcmF3SW5kZXggPCB2Lmxlbmd0aDsgKytkcmF3SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChmaWxsQ29sb3JGb3JJbmRleCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZmlsbENvbG9yRm9ySW5kZXgpKSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3JGb3JJbmRleFtkcmF3SW5kZXhdIHx8IG9wdGlvbnMuZmlsbENvbG9yQmFycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvckZvckluZGV4ICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShzdHJva2VDb2xvckZvckluZGV4KSkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvckZvckluZGV4W2RyYXdJbmRleF0gfHwgb3B0aW9ucy5zdHJva2VDb2xvckJhcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJ1bm5pbmdWYWx1ZSArPSB2W2RyYXdJbmRleF07XG4gICAgICAgICAgICB2YXIgcmVuZGVyQmFySGVpZ2h0ID0gTWF0aC5mbG9vcihyZW1haW5pbmdIZWlnaHQgKiBIZWxwZXJzLmdldEF4aXNSYXRpbyhtaW5DaGFydFZhbHVlLCBtYXhDaGFydFZhbHVlLCBydW5uaW5nVmFsdWUpKTtcbiAgICAgICAgICAgIHZhciByZW5kZXJVcFRvWSA9IHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gcmVuZGVyQmFySGVpZ2h0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHJlbmRlckJhckhlaWdodCAtIGxhc3RIZWlnaHQpIDwgb3B0aW9ucy5zdGFja2VkQmFyUGFkZGluZyArIDIpIHtcbiAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IHJlbmRlckJhckhlaWdodDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXJQYWRQID0gZHJhd0luZGV4ID4gMCA/IG9wdGlvbnMuc3RhY2tlZEJhclBhZGRpbmcgOiAwO1xuICAgICAgICAgICAgdmFyIHRTWCwgdFNZO1xuICAgICAgICAgICAgdmFyIHRFWCwgdEVZO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0U1ggPSByZW5kZXJTdGFydFggKyBjb21wdXRlZEJhclBhZGRpbmcsIHRTWSA9IHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gbGFzdEhlaWdodCAtIGJhclBhZFApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhyZW5kZXJTdGFydFggKyBjb21wdXRlZEJhclBhZGRpbmcsIHJlbmRlclVwVG9ZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odEVYID0gcmVuZGVyU3RhcnRYICsgKHdpZHRoUGVyQmFyIC0gMSkgLSBjb21wdXRlZEJhclBhZGRpbmcsIHRFWSA9IHJlbmRlclVwVG9ZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocmVuZGVyU3RhcnRYICsgKHdpZHRoUGVyQmFyIC0gMSkgLSBjb21wdXRlZEJhclBhZGRpbmcsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gbGFzdEhlaWdodCAtIGJhclBhZFApO1xuICAgICAgICAgICAgaWYgKGRyYXdJbmRleCA+IDApIGN0eC5saW5lVG8odFNYLCB0U1kpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIHZhciBoaW50O1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuaGludHMgIT0gbnVsbCAmJiBjb250ZW50LmhpbnRzW2luZGV4XSAhPSBudWxsICYmIChoaW50ID0gY29udGVudC5oaW50c1tpbmRleF1bZHJhd0luZGV4XSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLm1vdXNlTGlzdGVuZXJzLnB1c2goZnVuY3Rpb24oaW5kZXgsIGRyYXdJbmRleCwgaGludCwgc3gsIHN5LCBleCwgZXksIHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKHN4LCBleCksIG1heFggPSBNYXRoLm1heChzeCwgZXgpO1xuICAgICAgICAgICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4oc3ksIGV5KSwgbWF4WSA9IE1hdGgubWF4KHN5LCBleSk7XG4gICAgICAgICAgICAgICAgaWYgKHggPCBtaW5YIHx8IHggPiBtYXhYIHx8IHkgPCBtaW5ZIHx8IHkgPiBtYXhZKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXgsIGRyYXdJbmRleDogZHJhd0luZGV4LCByZWN0OiB7IGxlZnQ6IG1pblgsIHJpZ2h0OiBtYXhYLCB0b3A6IG1pblksIGJvdHRvbTogbWF4WSB9LCB0ZXh0OiBoaW50LnNwbGl0KCdcXG4nKSB9O1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcywgaW5kZXgsIGRyYXdJbmRleCwgaGludCwgdFNYLCB0U1ksIHRFWCwgdEVZKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YWdUZXh0O1xuICAgICAgICAgICAgaWYgKHRTWSAtIHJlbmRlclVwVG9ZID4gb3B0aW9ucy5mb250RGF0YVRhZ3MgKiAxLjI1ICYmIGNvbnRlbnQuZGF0YVRhZ3MgIT0gbnVsbCAmJiAodGFnVGV4dCA9IGNvbnRlbnQuZGF0YVRhZ3NbaW5kZXhdKSAhPSBudWxsICYmICh0YWdUZXh0ID0gdGFnVGV4dFtkcmF3SW5kZXhdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBvRlMgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG4gICAgICAgICAgICAgIGN0eC5mb250ID0gSGVscGVycy5nZXRGb250KHsgd2VpZ2h0OiBvcHRpb25zLmZvbnRXZWlnaHQsIHNpemU6IG9wdGlvbnMuZm9udERhdGFUYWdzLCBmYW1pbHk6IG9wdGlvbnMuZm9udCB9KTtcbiAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGFnVGV4dCwgcmVuZGVyU3RhcnRYICsgd2lkdGhQZXJCYXIgLyAyLCB0U1kgLSBvcHRpb25zLmZvbnREYXRhVGFncyAqIDAuMjUpO1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gb0ZTO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0SGVpZ2h0ID0gcmVuZGVyQmFySGVpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZW50LmJhclRvb2x0aXBzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDAsIDApJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gSGVscGVycy5nZXRGb250KHsgd2VpZ2h0OiBvcHRpb25zLmZvbnRXZWlnaHQsIHNpemU6IG9wdGlvbnMuZm9udFNpemVMYWJlbHMsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQuYmFyVG9vbHRpcHNbaW5kZXhdIHx8ICcnLCByZW5kZXJTdGFydFggKyB3aWR0aFBlckJhciAvIDIsIHJlbmRlclVwVG9ZIC0gMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYmFyU3R5bGUgPT09ICdsaW5lJykge1xuICAgICAgICAgIGlmICh2SXNBcnIpIHtcbiAgICAgICAgICAgIHZhciByYnggPSByZW5kZXJTdGFydFggKyB3aWR0aFBlckJhciAvIDI7XG5cbiAgICAgICAgICAgIHZhciBsRHU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWxsUmVnaW9uID09PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgbER1ID0gbGFzdERhdGE7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxEdSkpIGxEdSA9IGxEdVswXTtcbiAgICAgICAgICAgICAgaWYgKGxEdSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNGUyA9IGN0eC5maWxsU3R5bGVcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbER1LmNvbG9yXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGxEdS54LCBib3VuZFkxLCByYnggLSBsRHUueCwgYm91bmRZMiAtIGJvdW5kWTEpXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNGU1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuTERhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGRyYXdJbmRleCA9IDA7IGRyYXdJbmRleCA8IHYubGVuZ3RoOyArK2RyYXdJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgcmVuZGVyQmFySGVpZ2h0MyA9IE1hdGgucm91bmQocmVtYWluaW5nSGVpZ2h0ICogSGVscGVycy5nZXRBeGlzUmF0aW8obWluQ2hhcnRWYWx1ZSwgbWF4Q2hhcnRWYWx1ZSwgdltkcmF3SW5kZXhdKSk7XG4gICAgICAgICAgICAgIHZhciByZW5kZXJVcFRvWTMgPSB0b3BZUGFkZGluZyArIHJlbWFpbmluZ0hlaWdodCAtIHJlbmRlckJhckhlaWdodDM7XG5cbiAgICAgICAgICAgICAgdmFyIHJieSA9IHJlbmRlclVwVG9ZMztcbiAgICAgICAgICAgICAgaWYgKGxhc3REYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdExYLCB0TFk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFzdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgICB0TFggPSAobGFzdERhdGFbZHJhd0luZGV4XSB8fCB7IH0pLng7XG4gICAgICAgICAgICAgICAgICB0TFkgPSAobGFzdERhdGFbZHJhd0luZGV4XSB8fCB7IH0pLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRMWCA9IGxhc3REYXRhLng7XG4gICAgICAgICAgICAgICAgICB0TFkgPSBsYXN0RGF0YS55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0TFggJiYgdExZKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJva2VDb2xvckZvckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvckZvckluZGV4W2RyYXdJbmRleF0gfHwgb3B0aW9ucy5zdHJva2VDb2xvckJhcnM7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3JGb3JJbmRleCB8fCAncmdiKDAsIDAsIDApJztcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odExYLCB0TFkpO1xuICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyYngsIHJieSk7XG4gICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsbENvbG9yRm9ySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvckZvckluZGV4W2RyYXdJbmRleF0gfHwgb3B0aW9ucy5maWxsQ29sb3JCYXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9yRm9ySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3JGb3JJbmRleFtkcmF3SW5kZXhdIHx8IG9wdGlvbnMuc3Ryb2tlQ29sb3JCYXJzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBjdHguYXJjKHJieCwgcmJ5LCBvcHRpb25zLnJhZGl1c0RvdCwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgbkxEYXRhW2RyYXdJbmRleF0gPSB7IHg6IHJieCwgeTogcmJ5LCBjb2xvcjogY3R4LmZpbGxTdHlsZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdERhdGEgPSBuTERhdGE7XG4gICAgICAgICAgICBpZiAobER1ICE9IG51bGwgJiYgbER1LmNvbG9yICE9IGxhc3REYXRhWzBdLmNvbG9yKSB0aGlzLmZpbGxSZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgICB4OiBsYXN0RGF0YVswXS54LFxuICAgICAgICAgICAgICB5OiBsYXN0RGF0YVswXS55LFxuICAgICAgICAgICAgICBwcmV2OiBsRHUuY29sb3IsXG4gICAgICAgICAgICAgIG5leHQ6IGxhc3REYXRhWzBdLmNvbG9yXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAoY29udGVudC5iYWxscyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoY29udGVudC5iYWxscykgJiYgaW5kZXggPCBjb250ZW50LmJhbGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgYmFsbCA9IGNvbnRlbnQuYmFsbHNbaW5kZXhdXG4gICAgICAgICAgICAgIGlmIChiYWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhbGwuZmlsbDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBiYWxsLnN0cm9rZTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHJieCwgdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSAocmVtYWluaW5nSGVpZ2h0ICogSGVscGVycy5nZXRBeGlzUmF0aW8obWluQ2hhcnRWYWx1ZSwgbWF4Q2hhcnRWYWx1ZSwgbWluQ2hhcnRWYWx1ZSArIGJhbGwudmFsdWUpKSwgYmFsbC5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyQmFySGVpZ2h0MyA9IE1hdGgucm91bmQocmVtYWluaW5nSGVpZ2h0ICogSGVscGVycy5nZXRBeGlzUmF0aW8obWluQ2hhcnRWYWx1ZSwgbWF4Q2hhcnRWYWx1ZSwgdikpO1xuICAgICAgICAgICAgdmFyIHJlbmRlclVwVG9ZMyA9IHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gcmVuZGVyQmFySGVpZ2h0MztcblxuICAgICAgICAgICAgdmFyIHJieCA9IHJlbmRlclN0YXJ0WCArIHdpZHRoUGVyQmFyIC8gMiwgcmJ5ID0gcmVuZGVyVXBUb1kzO1xuICAgICAgICAgICAgdmFyIGxEdTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxSZWdpb24gPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgICBpZiAobGFzdERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxEdSA9IGxhc3REYXRhO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxEdSkpIGxEdSA9IGxEdVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc0ZTID0gY3R4LmZpbGxTdHlsZVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsRHUuY29sb3JcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QobER1LngsIGJvdW5kWTEsIHJieCAtIGxEdS54LCBib3VuZFkyIC0gYm91bmRZMSlcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc0ZTXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMocmJ4LCByYnksIG9wdGlvbnMucmFkaXVzRG90LCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICBpZiAobGFzdERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXN0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdExYLCB0TFk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxhc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWxhc3REYXRhLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgdExYID0gbGFzdERhdGFba2V5XS54O1xuICAgICAgICAgICAgICAgICAgdExZID0gbGFzdERhdGFba2V5XS55O1xuICAgICAgICAgICAgICAgICAgaWYgKHRMWCAmJiB0TFkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3JGb3JJbmRleCB8fCAncmdiKDAsIDAsIDApJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRMWCwgdExZKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyYngsIHJieSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRMWCA9IGxhc3REYXRhLngsIHRMWSA9IGxhc3REYXRhLnk7XG4gICAgICAgICAgICAgICAgaWYgKHRMWCAmJiB0TFkpIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yRm9ySW5kZXggfHwgJ3JnYigwLCAwLCAwKSc7XG4gICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRMWCwgdExZKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocmJ4LCByYnkpO1xuICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0RGF0YSA9IHsgeDogcmJ4LCB5OiByYnksIGNvbG9yOiBjdHguZmlsbFN0eWxlIH07XG4gICAgICAgICAgICBpZiAobER1ICE9IG51bGwgJiYgbER1LmNvbG9yICE9IGxhc3REYXRhLmNvbG9yKSB0aGlzLmZpbGxSZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgICB4OiBsYXN0RGF0YS54LFxuICAgICAgICAgICAgICB5OiBsYXN0RGF0YS55LFxuICAgICAgICAgICAgICBwcmV2OiBsRHUuY29sb3IsXG4gICAgICAgICAgICAgIG5leHQ6IGxhc3REYXRhLmNvbG9yXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAoY29udGVudC5iYWxscyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoY29udGVudC5iYWxscykgJiYgaW5kZXggPCBjb250ZW50LmJhbGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgYmFsbCA9IGNvbnRlbnQuYmFsbHNbaW5kZXhdXG4gICAgICAgICAgICAgIGlmIChiYWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhbGwuZmlsbDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBiYWxsLnN0cm9rZTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHJieCwgdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQgLSAocmVtYWluaW5nSGVpZ2h0ICogSGVscGVycy5nZXRBeGlzUmF0aW8obWluQ2hhcnRWYWx1ZSwgbWF4Q2hhcnRWYWx1ZSwgbWluQ2hhcnRWYWx1ZSArIGJhbGwudmFsdWUpKSwgYmFsbC5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoaW50O1xuICAgICAgICAgIGlmIChjb250ZW50LmhpbnRzICE9IG51bGwgJiYgKGhpbnQgPSBjb250ZW50LmhpbnRzW2luZGV4XSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKGluZGV4LCBoaW50LCBzeCwgc3ksIGV4LCBleSwgeCwgeSkge1xuICAgICAgICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKHN4LCBleCksIG1heFggPSBNYXRoLm1heChzeCwgZXgpO1xuICAgICAgICAgICAgICB2YXIgbWluWSA9IE1hdGgubWluKHN5LCBleSksIG1heFkgPSBNYXRoLm1heChzeSwgZXkpO1xuICAgICAgICAgICAgICBpZiAoeCA8IG1pblggfHwgeCA+IG1heFggfHwgeSA8IG1pblkgfHwgeSA+IG1heFkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXgsIGRyYXdJbmRleDogZHJhd0luZGV4LCByZWN0OiB7IGxlZnQ6IG1pblgsIHJpZ2h0OiBtYXhYLCB0b3A6IG1pblksIGJvdHRvbTogbWF4WSB9LCB0ZXh0OiBoaW50LnNwbGl0KCdcXG4nKSB9O1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMsIGluZGV4LCBoaW50LCByYnggLSAxLCB0b3BZUGFkZGluZywgcmJ4ICsgMSwgdG9wWVBhZGRpbmcgKyByZW1haW5pbmdIZWlnaHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZJc0FycikgdiA9IEhlbHBlcnMuYXZnKHYpO1xuICAgICAgICAgIHZhciByZW5kZXJCYXJIZWlnaHQyID0gTWF0aC5yb3VuZChyZW1haW5pbmdIZWlnaHQgKiBIZWxwZXJzLmdldEF4aXNSYXRpbyhtaW5DaGFydFZhbHVlLCBtYXhDaGFydFZhbHVlLCB2KSk7XG4gICAgICAgICAgdmFyIHJlbmRlclVwVG9ZMiA9IHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0IC0gcmVuZGVyQmFySGVpZ2h0MjtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhyZW5kZXJTdGFydFggKyBjb21wdXRlZEJhclBhZGRpbmcsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0KTtcbiAgICAgICAgICBjdHgubGluZVRvKHJlbmRlclN0YXJ0WCArIGNvbXB1dGVkQmFyUGFkZGluZywgcmVuZGVyVXBUb1kyKTtcbiAgICAgICAgICBjdHgubGluZVRvKHJlbmRlclN0YXJ0WCArICh3aWR0aFBlckJhciAtIDEpIC0gY29tcHV0ZWRCYXJQYWRkaW5nLCByZW5kZXJVcFRvWTIpO1xuICAgICAgICAgIGN0eC5saW5lVG8ocmVuZGVyU3RhcnRYICsgKHdpZHRoUGVyQmFyIC0gMSkgLSBjb21wdXRlZEJhclBhZGRpbmcsIHRvcFlQYWRkaW5nICsgcmVtYWluaW5nSGVpZ2h0KTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmJhclN0eWxlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgaWYgKCh2YWwgPSBjb250ZW50Ll9kYXRhX3N0YW5kYXJkX2Vycm9yW2luZGV4XSkgIT0gMCkge1xuICAgICAgICAgICAgICB2YXIgcmVuZGVyQmFyRXJyb3IgPSBNYXRoLnJvdW5kKHJlbWFpbmluZ0hlaWdodCAqIEhlbHBlcnMuZ2V0QXhpc1JhdGlvKG1pbkNoYXJ0VmFsdWUsIG1heENoYXJ0VmFsdWUsIHZhbCkpO1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIHZhciB3aXNrZXJXaWR0aCA9IE1hdGgucm91bmQoKHdpZHRoUGVyQmFyIC0gY29tcHV0ZWRCYXJQYWRkaW5nICogMikgLyA4KTtcbiAgICAgICAgICAgICAgdmFyIHhfID0gbGVmdFhQYWRkaW5nICsgd2lkdGhQZXJCYXIgKiBpbmRleCArIHdpZHRoUGVyQmFyIC8gMjtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4XyAtIHdpc2tlcldpZHRoLCByZW5kZXJVcFRvWTIgKyByZW5kZXJCYXJFcnJvcik7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeF8gKyB3aXNrZXJXaWR0aCwgcmVuZGVyVXBUb1kyICsgcmVuZGVyQmFyRXJyb3IpO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHhfLCByZW5kZXJVcFRvWTIgKyByZW5kZXJCYXJFcnJvcik7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeF8sIHJlbmRlclVwVG9ZMiAtIHJlbmRlckJhckVycm9yKTtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4XyAtIHdpc2tlcldpZHRoLCByZW5kZXJVcFRvWTIgLSByZW5kZXJCYXJFcnJvcik7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeF8gKyB3aXNrZXJXaWR0aCwgcmVuZGVyVXBUb1kyIC0gcmVuZGVyQmFyRXJyb3IpO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRlbnQuYmFyVG9vbHRpcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZUxhYmVscywgZmFtaWx5OiBvcHRpb25zLmZvbnQgfSk7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudC5iYXJUb29sdGlwc1tpbmRleF0gfHwgJycsIHJlbmRlclN0YXJ0WCArIHdpZHRoUGVyQmFyIC8gMiwgcmVuZGVyVXBUb1kyIC0gMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGludCAhPSBudWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZhciBoUmVjdCA9IHRoaXMuY3VycmVudEhpbnQucmVjdCwgaGludHMgPSB0aGlzLmN1cnJlbnRIaW50LnRleHQ7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDAsIDApJztcbiAgICAgICAgY3R4LmZvbnQgPSBIZWxwZXJzLmdldEZvbnQoeyB3ZWlnaHQ6IG9wdGlvbnMuZm9udFdlaWdodCwgc2l6ZTogb3B0aW9ucy5mb250U2l6ZUhpbnQsIGZhbWlseTogb3B0aW9ucy5mb250IH0pO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB2YXIgYm94V2lkdGggPSAwO1xuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBoaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICBib3hXaWR0aCA9IE1hdGgubWF4KGJveFdpZHRoLCBNYXRoLmNlaWwoY3R4Lm1lYXN1cmVUZXh0KGhpbnRzW2luZGV4XSkud2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm94V2lkdGhQYWRkaW5nID0gNTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBvcHRpb25zLmZvbnRTaXplSGludCAqIDEuNTtcbiAgICAgICAgdmFyIGJveEhlaWdodCA9IGhpbnRzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBkcmF3WCA9IGhSZWN0LnJpZ2h0ICsgMTAsIGRyYXdZID0gKGhSZWN0LnRvcCArIGhSZWN0LmJvdHRvbSkgLyAyO1xuICAgICAgICBib3hXaWR0aCArPSBib3hXaWR0aFBhZGRpbmcgKiAyO1xuICAgICAgICBpZiAoZHJhd1ggKyBib3hXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgZHJhd1ggPSBoUmVjdC5sZWZ0IC0gYm94V2lkdGggLSAxMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhd1kgLSBib3hIZWlnaHQgLyAyIDwgMCkge1xuICAgICAgICAgIGRyYXdZID0gTWF0aC5jZWlsKGJveEhlaWdodCAvIDIpICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChkcmF3WSArIGJveEhlaWdodCAvIDIgPiBoZWlnaHQpIHtcbiAgICAgICAgICBkcmF3WSA9IGhlaWdodCAtIGJveEhlaWdodCAvIDIgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbGVhclJlY3QoZHJhd1gsIGRyYXdZIC0gYm94SGVpZ2h0IC8gMiwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoZHJhd1gsIGRyYXdZIC0gYm94SGVpZ2h0IC8gMiwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgaGludHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGhpbnRzW2luZGV4XSwgZHJhd1ggKyBib3hXaWR0aFBhZGRpbmcsIGRyYXdZIC0gYm94SGVpZ2h0IC8gMiArIG9wdGlvbnMuZm9udFNpemVIaW50ICsgaW5kZXggKiBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgudHJhbnNsYXRlKDAuNSwgMC41KTtcblxuICAgICAgdGhpcy5sYWJlbFBvc2l0aW9ucyA9IGxhYmVsUG9zaXRpb25zO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmFyQ2hhcnQ7XG4gIH0pKCk7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJhckNoYXJ0O1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5CYXJDaGFydCA9IEJhckNoYXJ0O1xuICB9XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogQ2hhcnQuanMgZG9jczogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmcvICovXHJcbndpbmRvdy5jaGFydENvbG9ycyA9IHtcclxuXHRncmVlbjogJyM3NWMxODEnLFxyXG5cdGdyYXk6ICcjYTliNWM5JyxcclxuXHR0ZXh0OiAnIzI1MjkzMCcsXHJcblx0Ym9yZGVyOiAnI2U3ZTllZCdcclxufTtcclxuXHJcbi8qIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZvciBkZW1vIHB1cnBvc2UgKi9cclxudmFyIHJhbmRvbURhdGFQb2ludCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSB9O1xyXG5cclxuLy9DaGFydC5qcyBMaW5lIENoYXJ0IEV4YW1wbGUgXHJcbnZhciBsaW5lQ2hhcnRDb25maWcgPSB7XHJcblx0dHlwZTogJ2xpbmUnLFxyXG5cclxuXHRkYXRhOiB7XHJcblx0XHRsYWJlbHM6IFsnRGF5IDEnLCAnRGF5IDInLCAnRGF5IDMnLCAnRGF5IDQnLCAnRGF5IDUnLCAnRGF5IDYnLCAnRGF5IDcnXSxcclxuXHJcblx0XHRkYXRhc2V0czogW3tcclxuXHRcdFx0bGFiZWw6ICdDdXJyZW50IHdlZWsnLFxyXG5cdFx0XHRmaWxsOiBmYWxzZSxcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuZ3JlZW4sXHJcblx0XHRcdGJvcmRlckNvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuZ3JlZW4sXHJcblx0XHRcdGRhdGE6IFtcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKVxyXG5cdFx0XHRdLFxyXG5cdFx0fSwge1xyXG5cdFx0XHRsYWJlbDogJ1ByZXZpb3VzIHdlZWsnLFxyXG5cdFx0XHRib3JkZXJEYXNoOiBbMywgNV0sXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLmdyYXksXHJcblx0XHRcdGJvcmRlckNvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuZ3JheSxcclxuXHJcblx0XHRcdGRhdGE6IFtcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKSxcclxuXHRcdFx0XHRyYW5kb21EYXRhUG9pbnQoKVxyXG5cdFx0XHRdLFxyXG5cdFx0XHRmaWxsOiBmYWxzZSxcclxuXHRcdH1dXHJcblx0fSxcclxuXHRvcHRpb25zOiB7XHJcblx0XHRyZXNwb25zaXZlOiB0cnVlLFxyXG5cdFx0YXNwZWN0UmF0aW86IDEuNSxcclxuXHJcblx0XHRsZWdlbmQ6IHtcclxuXHRcdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cdFx0XHRhbGlnbjogJ2VuZCcsXHJcblx0XHR9LFxyXG5cclxuXHRcdHRpdGxlOiB7XHJcblx0XHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRcdHRleHQ6ICdDaGFydC5qcyBMaW5lIENoYXJ0IEV4YW1wbGUnLFxyXG5cclxuXHRcdH0sXHJcblx0XHR0b29sdGlwczoge1xyXG5cdFx0XHRtb2RlOiAnaW5kZXgnLFxyXG5cdFx0XHRpbnRlcnNlY3Q6IGZhbHNlLFxyXG5cdFx0XHR0aXRsZU1hcmdpbkJvdHRvbTogMTAsXHJcblx0XHRcdGJvZHlTcGFjaW5nOiAxMCxcclxuXHRcdFx0eFBhZGRpbmc6IDE2LFxyXG5cdFx0XHR5UGFkZGluZzogMTYsXHJcblx0XHRcdGJvcmRlckNvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuYm9yZGVyLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXHJcblx0XHRcdGJvZHlGb250Q29sb3I6IHdpbmRvdy5jaGFydENvbG9ycy50ZXh0LFxyXG5cdFx0XHR0aXRsZUZvbnRDb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLnRleHQsXHJcblxyXG5cdFx0XHRjYWxsYmFja3M6IHtcclxuXHRcdFx0XHQvL1JlZjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg4MDAyMjYvY2hhcnQtanMtYWRkLWNvbW1hcy10by10b29sdGlwLWFuZC15LWF4aXNcclxuXHRcdFx0XHRsYWJlbDogZnVuY3Rpb24gKHRvb2x0aXBJdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRpZiAocGFyc2VJbnQodG9vbHRpcEl0ZW0udmFsdWUpID49IDEwMDApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiJFwiICsgdG9vbHRpcEl0ZW0udmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIixcIik7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJyQnICsgdG9vbHRpcEl0ZW0udmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdH0sXHJcblx0XHRob3Zlcjoge1xyXG5cdFx0XHRtb2RlOiAnbmVhcmVzdCcsXHJcblx0XHRcdGludGVyc2VjdDogdHJ1ZVxyXG5cdFx0fSxcclxuXHRcdHNjYWxlczoge1xyXG5cdFx0XHR4QXhlczogW3tcclxuXHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdFx0ZHJhd0JvcmRlcjogZmFsc2UsXHJcblx0XHRcdFx0XHRjb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLmJvcmRlcixcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNjYWxlTGFiZWw6IHtcclxuXHRcdFx0XHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1dLFxyXG5cdFx0XHR5QXhlczogW3tcclxuXHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdFx0ZHJhd0JvcmRlcjogZmFsc2UsXHJcblx0XHRcdFx0XHRjb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLmJvcmRlcixcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNjYWxlTGFiZWw6IHtcclxuXHRcdFx0XHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGlja3M6IHtcclxuXHRcdFx0XHRcdGJlZ2luQXRaZXJvOiB0cnVlLFxyXG5cdFx0XHRcdFx0dXNlckNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCB2YWx1ZXMpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICckJyArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7ICAgLy9SZWY6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4ODAwMjI2L2NoYXJ0LWpzLWFkZC1jb21tYXMtdG8tdG9vbHRpcC1hbmQteS1heGlzXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fV1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBDaGFydC5qcyBCYXIgQ2hhcnQgRXhhbXBsZSBcclxudmFyIGJhckNoYXJ0Q29uZmlnID0ge1xyXG5cdHR5cGU6ICdiYXInLFxyXG5cclxuXHRkYXRhOiB7XHJcblx0XHRsYWJlbHM6IFsnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnLCAnU3VuJ10sXHJcblx0XHRkYXRhc2V0czogW3tcclxuXHRcdFx0bGFiZWw6ICdPcmRlcnMnLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHdpbmRvdy5jaGFydENvbG9ycy5ncmVlbixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IHdpbmRvdy5jaGFydENvbG9ycy5ncmVlbixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IDEsXHJcblx0XHRcdG1heEJhclRoaWNrbmVzczogMTYsXHJcblxyXG5cdFx0XHRkYXRhOiBbXHJcblx0XHRcdFx0MjMsXHJcblx0XHRcdFx0NDUsXHJcblx0XHRcdFx0NzYsXHJcblx0XHRcdFx0NzUsXHJcblx0XHRcdFx0NjIsXHJcblx0XHRcdFx0MzcsXHJcblx0XHRcdFx0ODNcclxuXHRcdFx0XVxyXG5cdFx0fV1cclxuXHR9LFxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHJlc3BvbnNpdmU6IHRydWUsXHJcblx0XHRhc3BlY3RSYXRpbzogMS41LFxyXG5cdFx0bGVnZW5kOiB7XHJcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcclxuXHRcdFx0YWxpZ246ICdlbmQnLFxyXG5cdFx0fSxcclxuXHRcdHRpdGxlOiB7XHJcblx0XHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRcdHRleHQ6ICdDaGFydC5qcyBCYXIgQ2hhcnQgRXhhbXBsZSdcclxuXHRcdH0sXHJcblx0XHR0b29sdGlwczoge1xyXG5cdFx0XHRtb2RlOiAnaW5kZXgnLFxyXG5cdFx0XHRpbnRlcnNlY3Q6IGZhbHNlLFxyXG5cdFx0XHR0aXRsZU1hcmdpbkJvdHRvbTogMTAsXHJcblx0XHRcdGJvZHlTcGFjaW5nOiAxMCxcclxuXHRcdFx0eFBhZGRpbmc6IDE2LFxyXG5cdFx0XHR5UGFkZGluZzogMTYsXHJcblx0XHRcdGJvcmRlckNvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuYm9yZGVyLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXHJcblx0XHRcdGJvZHlGb250Q29sb3I6IHdpbmRvdy5jaGFydENvbG9ycy50ZXh0LFxyXG5cdFx0XHR0aXRsZUZvbnRDb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLnRleHQsXHJcblxyXG5cdFx0fSxcclxuXHRcdHNjYWxlczoge1xyXG5cdFx0XHR4QXhlczogW3tcclxuXHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdFx0ZHJhd0JvcmRlcjogZmFsc2UsXHJcblx0XHRcdFx0XHRjb2xvcjogd2luZG93LmNoYXJ0Q29sb3JzLmJvcmRlcixcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0fV0sXHJcblx0XHRcdHlBeGVzOiBbe1xyXG5cdFx0XHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRcdFx0Z3JpZExpbmVzOiB7XHJcblx0XHRcdFx0XHRkcmF3Qm9yZGVyOiBmYWxzZSxcclxuXHRcdFx0XHRcdGNvbG9yOiB3aW5kb3cuY2hhcnRDb2xvcnMuYm9yZGVycyxcclxuXHRcdFx0XHR9LFxyXG5cclxuXHJcblx0XHRcdH1dXHJcblx0XHR9XHJcblxyXG5cdH1cclxufVxyXG5cclxuLy8gR2VuZXJhdGUgY2hhcnRzIG9uIGxvYWRcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaW5lQ2hhcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWxpbmVjaGFydCcpLmdldENvbnRleHQoJzJkJyk7XHJcblx0d2luZG93Lm15TGluZSA9IG5ldyBDaGFydChsaW5lQ2hhcnQsIGxpbmVDaGFydENvbmZpZyk7XHJcblxyXG5cdHZhciBiYXJDaGFydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtYmFyY2hhcnQnKS5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdHdpbmRvdy5teUJhciA9IG5ldyBDaGFydChiYXJDaGFydCwgYmFyQ2hhcnRDb25maWcpO1xyXG59KTtcclxuIl19
